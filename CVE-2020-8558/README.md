# 漏洞分析

## 一、漏洞基本信息

| Item           | Details                                          | Note              |
| -------------- | ------------------------------------------------ | ----------------- |
| Project        | Kubernetes                                       |                   |
| Publish Date   | 2020-07-27                                       |                   |
| Confirm        | https://github.com/kubernetes/kubernetes/issues/92315|             |
| CVE-ID         | CVE-2020-8558                                 | NVD  |
| Exploits       | disclose                                         |       |
| Affect Version | kubelet/kube-proxy v1.18.0-1.18.3  kubelet/kube-proxy v1.17.0-1.17.6 kubelet/kube-proxy <=1.16.10 |             |
| Fix Version    | Although the issue is caused by `kube-proxy`, the current fix for the issue is in `kubelet` (although future versions may have the fix in `kube-proxy` instead)     v1.18.4+    v1.18.4+ v1.16.11+ |                   |
| Fix Commit     | https://github.com/kubernetes/kubernetes/pull/91569/commits |      |
| CVSS           | 8.8 CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |                   |
| Vuln’s Author  | János Kövér, Ericsson with additional impacts reported by Rory McCune, NCC Group and Yuval Avrahami and Ariel Zelivansky, Palo Alto Networks. |                   |

## 二、组件简介

kube-porxy，也就是Kubernetes network proxy，在每个节点上运行。负责实现Kubernetes 节点上的API，并且可以各种网络转发。该组件负责管理节点的网络，需要关注网络访问控制相关问题。

## 三、漏洞详情

### 1. 介绍

Kube-porxy的网络配置可以让"容器内的恶意用户、同一局域网其他机器"访问到node节点上"仅绑定在127.0.0.1的服务"

### 2. 影响

访问node节点本地服务，有可能访问到"kubernetes无需认证的apiserver或者kubelet"，进而控制集群。

## 四、防御

## 五、漏洞复现

复现场景为pod访问node上绑定在127.0.0.1上的服务（poc中使用nc监听在127.0.0.1:8888）。pod中使用python脚本来修改发送/接收的报文，把pod中发往node本地回环地址的报文中的mac地址替换为node节点网卡的mac，把node回复报文中的目的ip改为伪造地址，为了避免容器网卡反向检查源IP。

### 1. 复现环境

```
docker pull noirfate/vul-k8s-cve-2020-8558:1.0
```

### 2. 复现过程

```
docker-compose up
ssh -p12222 root@127.0.0.1
cd exploit
./run
```

## 六、漏洞分析

kube-proxy通过[sysctl文件](https://www.kernel.org/doc/Documentation/sysctl/README)来配置网络参数，其中一个`net.ipv4.conf.all.route_localnet`是导致这个漏洞出现的罪魁祸首。

kube-proxy会将`net.ipv4.conf.all.route_localnet`设置为非默认的true，却没有加其他的安全防范，这会使系统接收目的地址为`127.0.0.0/8`的包。

攻击者将发送的包进行篡改，MAC地址设置为访问目标的MAC，目的地址改为127.0.0.1，由于IP地址无效，包通过二层网络根据MAC地址发送给目标网卡，目标设备接收到恶意数据包之后，route_localnet的设置允许这个包通过，因为这个包的目的IP为127.0.0.1，那么它将被允许访问localhost服务。

由于kube-proxy的存在，集群中的每一个节点都启用了route_localnet。因此，节点本地网络中的每一台主机都将能够访问节点的内部服务，运行在节点内的Pods同样能够访问节点的内部服务，攻击值可能利用此漏洞防卫访问暴露的服务尝试横向移动和逃逸。

### 参考

https://github.com/tabbysable/POC-2020-8558<br>
https://unit42.paloaltonetworks.com/cve-2020-8558/<br>
https://www.freebuf.com/vuls/245955.html<br>
https://mp.weixin.qq.com/s/hvb_Kr6DqAPPfnN-lbx1aA

## 七、漏洞修复分析

[第一次修改](https://github.com/kubernetes/kubernetes/pull/91569/commits/8bed088224fb38b41255b37e59a1701caefa171b)kubelet添加了一条iptables规则

```shell
root@ip-172-31-14-33:~# iptables-save |grep localnet
-A KUBE-FIREWALL ! -s 127.0.0.0/8 -d 127.0.0.0/8 -m comment --comment "block incoming localnet connections" -m conntrack ! --ctstate RELATED,ESTABLISHED,DNAT -j DROP
```

这条规则使得，在tcp握手时，第一个syn包如果目的ip是"环回地址"，同时源ip不是"环回地址"时，包会被丢弃，从而防止了非本机的地址来源。

但是[有人提出](https://github.com/kubernetes/kubernetes/pull/91569#issuecomment-637161223)如果源IP也经过伪造，那么对于可以不考虑返回的如udp包仍然可以通过这条规则，于是源IP判断[改成了对interface进行判断](https://github.com/kubernetes/kubernetes/pull/91666/commits/07b7cde684c9865bc5ddaae15cf4a5fb9e72bea9)

```shell
iptables -A KUBE-FIREWALL ! -i lo --dst 127.0.0.0/8 --comment "block incoming localnet connections" -m conntrack ! --ctstate 'RELATED,ESTABLISHED,DNAT' -j DROP
```

## 八、漏洞挖掘方法与过程

## 九、同类问题挖掘方法

### 设计实现层
### Fuzz
### codeql


## 十、时间线
